Service: Terrain

Types: integer, boolean, enum Direction { HAUT, BAS, GAUCHE, DROITE }, enum TypeBloc { VIDE, TERRE, MUR, HERO, SORTIE_FERMEE, SORTIE_OUVERTE, ROCHER, DIAMANT }

Use: Bloc, Position

Observators:
	const getLargeur : [Terrain] -> integer
	const getHauteur : [Terrain] -> integer
	getPosSortie : [Terrain] -> Position
	getPosHero : [Terrain] -> Position
	getBlocHero : [Terrain] -> Bloc
		pre getBlocHero(t) require isHeroVivant(t)
	getBloc : [Terrain] * Position -> Bloc
	getBlocVersDirection : [Terrain] * Bloc * Direction -> Bloc
	isHeroVivant : [Terrain] -> boolean
	isDiamantsRestants : [Terrain] -> boolean
	isDeplacementBlocPossible : [Terrain] * Bloc * Direction -> boolean
	
Constructors:
	init : integer * integer -> [Terrain]
		pre init(l, h) require l > 0 ^ h > 0
	
Operators:
	setBloc : [Terrain] * TypeBloc * integer * integer -> [Terrain]
	deplacerBlocVersDirection : [Terrain] * Bloc * Direction -> [Terrain]
		pre deplacerBlocVersDirection(t, bloc, dir) require isDeplacementBlocPossible(t, bloc, dir)
	fairePasDeMiseAJour : [Terrain] -> [Terrain]
	
Observations:
	[invariants]
		getBlocVersDirection(t, bloc, dir) ={min} getBloc(t, Position::deplacerVersDirection(Bloc::getPosition(bloc), dir))
		isHeroVivant(t) ={min} ∃x,y tq. Bloc::getType(getBloc(t, x, y)) = HERO
		isDiamantsRestants(t) ={min} ∃x,y tq. Bloc::getType(getBloc(t, x, y)) = DIAMANT
		isDeplacementBlocPossible(t, bloc, dir) ={min} ¬Bloc::isSolide(getBlocVersDirection(t, bloc, dir))

	[init]
		getLargeur(init(l, h)) = l
		getHauteur(init(l, h)) = h
		getPosSortie(init(l, h)) = null
		getPosHero(init(l, h)) = null
		getBlocHero(init(l, h)) = null
		getBloc(init(l, h), p) = null
	
	[setBloc]
		getPosSortie(setBloc(t, type, x, y)) =
			if type = SORTIE_FERMEE then
				Position::init(t, x, y)
			else
				getPosSortie(t)
		getPosHero(setBloc(t, type, x, y)) =
			if type = HERO then
				Position::init(t, x, y)
			else
				getPosHero(t)
		getBlocHero(setBloc(t, type, x, y)) =
			if type = HERO then
				Bloc::init(type, Position::init(t, x, y))
			else
				getBlocHero(t)
		getBloc(setBloc(t, type, x, y), pos) =
			let posBloc = Position::init(t, x, y)
			in
				if pos = posBloc then
					Bloc::init(type, pos)
				else
					getBloc(t, pos)
	
	[deplacerBlocVersDirection]
		getPosSortie(deplacerBlocVersDirection(t, bloc, dir)) = getPosSortie(t)
		getPosHero(deplacerBlocVersDirection(t, bloc, dir)) =
			if bloc = getBlocHero(t) then
				Bloc::getPosition(getBlocVersDirection(t, bloc, dir))
			else
				getPosHero(t)
		getBlocHero(deplacerBlocVersDirection(t, bloc, dir)) =
			if bloc = getBlocHero(t) then
				Bloc::setType(getBlocVersDirection(t, bloc, dir), HERO)
			else
				getBlocHero(t)
		getBloc(deplacerBlocVersDirection(t, bloc, dir), pos) =
			let* blocDest = getBlocVersDirection(t, bloc, dir)
			and posDest = Bloc::getPosition(blocDest)
			and posOrig = Bloc::getPosition(bloc)
			in
				if pos = posDest then
					Bloc::setType(blocDest, Bloc::getType(bloc))
				else if pos = posOrig then
					Bloc::setType(bloc, VIDE)
				else
					getBloc(t, pos)
	
	[fairePasDeMiseAJour]
		getPosSortie(fairePasDeMiseAJour(t)) = getPosSortie(t)
		getPosHero(fairePasDeMiseAJour(t)) = getPosHero(t)
		getBlocHero(fairePasDeMiseAJour(t)) = getBlocHero(t)
		∀x ∈ 0..getLargeur(t) - 1, y ∈ getHauteur(t) - 1..0, pos = (x, y) getBloc(fairePasDeMiseAJour(t), pos) =
			let bloc = getBloc(t, pos)
			in
				if Bloc::isSortieFermee(bloc) ^ ¬isDiamantsRestants(t) then
					Bloc::setType(bloc, SORTIE_OUVERTE)
				else if Bloc::isTombable(bloc) ^ Bloc::isVide(getBlocVersDirection(t, bloc, BAS))
					Bloc::setType(bloc, VIDE)
				else if Bloc::isVide(bloc) ^ Bloc::isTombable(getBlocVersDirection(t, bloc, HAUT))
					Bloc::setType(bloc, Bloc::getType(getBlocVersDirection(t, bloc, HAUT)))
				else
					getBloc(t, pos)
					