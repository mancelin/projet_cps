\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{lmodern}
\usepackage{fullpage}

\usepackage{pbox}
\usepackage{titlesec}
% \titlespacing*{\chapter}{0pt}{0pt}{0pt}
\usepackage{graphicx}
\usepackage[parfill]{parskip}
\usepackage[colorlinks=true, urlcolor=black, linkcolor=black, citecolor=black]{hyperref}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{tabto}

% Listings --------------------------------------------------------------------%
\usepackage{color}
\usepackage[usenames,dvipsnames]{xcolor}
\usepackage{listings}
\usepackage{caption}
\usepackage{wrapfig}

\DeclareCaptionFont{white}{\color{white}}
\DeclareCaptionFormat{listing}{\colorbox[cmyk]{0, 0, 0, 1}{\parbox{\textwidth}{\center{#3}}}\vspace{5pt}}
\captionsetup[lstlisting]{format=listing,labelfont=white,textfont=white, singlelinecheck=false, margin=0pt, font={bf, Large}}
\lstset{
	breaklines=true,
	tabsize=4,
	basicstyle=\normalsize\ttfamily,
	% basicstyle=\large\ttfamily,
	columns=fullflexible,
	showstringspaces=false,
	numberstyle=\tiny,
	numbersep=5pt,
	extendedchars=true,
	showspaces=false,
	xleftmargin=8pt,
	xrightmargin=8pt,
	framexleftmargin=17pt,
	framexrightmargin=5pt,
	framexbottommargin=4pt,
	morekeywords={const, if, then, else, pre, require, const, Set, enum, let, and, in}
}

% use latex commands inside ` ... `
\lstset{escapeinside={\`\'}}
%------------------------------------------------------------------------------%

% Todos -----------------------------------------------------------------------%
\setlength{\marginparwidth}{1.2in}
\let\oldmarginpar\marginpar
\renewcommand\marginpar[1]{\-\oldmarginpar[\raggedleft\footnotesize #1]%
{\raggedright\footnotesize #1}}
\newcommand{\note}[1]{\marginpar{\colorbox{yellow}{\begin{minipage}{\linewidth}\textcolor{black}{#1}\end{minipage}}}}
%------------------------------------------------------------------------------%

\newcommand{\tb}{\textbackslash{}}
\newcommand{\cmd}[1]{\texttt{#1}}
\newcommand{\fleche}{$\rightarrow{}$}
\newcommand{\X}{$\times{}$}
\newcommand{\eqmin}{$\overset{min}{=}$}
\newcommand{\eqdef}{$\overset{def}{=}$}
\newcommand{\supeq}{$\geq$~}
\newcommand{\infeq}{$\leq$~}
\newcommand{\noteq}{$\neq$~}


\newcommand{\lIN}[1]{{\tb}in \{~#1~\}}
\newcommand{\lAND}{$\land$}
\newcommand{\lOR}{$\lor$}
\newcommand{\lNOT}{$\lnot$}
\newcommand{\lFORALL}{$\forall$}
\newcommand{\lEXISTS}{$\exists$}
\newcommand{\lNEXISTS}{$\nexists{}$}
\newcommand{\lin}{$\in$}

\renewcommand{\o}[1]{\textcolor{blue}{#1}}
\renewcommand{\c}[1]{\textcolor{red}{#1}}
\newcommand{\eo}[1]{\textcolor{RoyalPurple}{#1}}
\newcommand{\ec}[1]{\textcolor{BrickRed}{#1}}

\newcommand{\obj}[2]{\subsubsection*{\large{\textbf{Objectif {\cmd{#1} (#2)}}}}}
\newenvironment{cas}[1]
{
	\hspace{1em}\textbf{Cas de test} \cmd{#1} :
	\begin{list}{}{}
}{
	\end{list}\vspace{1em}
}
\newcommand{\pre}[1]{\item \textbf{Préambule :} \cmd{#1}}
\newcommand{\npre}{\item \textbf{Préambule :} $\emptyset$}
\newcommand{\ope}[1]{\item \textbf{Contenu :} \cmd{#1}}
\newcommand{\nope}{\item \textbf{Contenu :} $\emptyset$}
\newcommand{\ora}[1]{\item \textbf{Oracle :} \cmd{#1}}
\newcommand{\oram}{\item \textbf{Oracle :}}
\newcommand{\opem}{\item \textbf{Contenu :}}
\newcommand{\prem}{\item \textbf{Préambule :}}


\title{Objectifs de Tests}

\author{}

\date{}

\begin{document}

\maketitle{}

\section{\emph{Stubs} utilisés}

Les objets de test suivant peuvent être référencés dans les cas de test :

\subsection{Le terrain TER1}

\cmd{TER1 \eqdef{} Terrain::init(5, 3)}

Avec pour blocs :

\begin{verbatim}
.####
.OX.Y
....?
\end{verbatim}

\begin{itemize}
	\item \cmd{X} héro
	\item \cmd{\#} mur
	\item \cmd{.} vide
	\item \cmd{O} rocher
	\item \cmd{Y} diamant
	\item \cmd{?} sortie fermée
\end{itemize}

\subsection{La position POS1}

\cmd{POS1 \eqdef{} Position::init(5, 3, 1, 1)}

\clearpage{}




\section{Bloc}

\subsection{Couverture des préconditions}

Aucune précondition dans Bloc.

\subsection{Couverture des invariants}

\obj{Bloc\_invariant1} {minimisation de isVide}

	\begin{cas}{Bloc\_invariant1}
		\pre{B = init(VIDE, POS1)}
		\nope{}
		\ora{isVide(B)}
	\end{cas}


\obj{Bloc\_invariant2} {minimisation de isSolide}

	\begin{cas}{Bloc\_invariant2}
		\pre{B = init(ROCHER, POS1)}
		\nope{}
		\ora{isSolide(B)}
	\end{cas}


\obj{Bloc\_invariant3} {minimisation de isDeplacable}
	\begin{cas}{Bloc\_invariant3}
		\pre{B = init(ROCHER, POS1)}
		\nope{}
		\ora{isDeplacable(B)}
	\end{cas}

\obj{Bloc\_invariant4} {minimisation de isTombable}
	\begin{cas}{Bloc\_invariant4}
		\pre{B = init(ROCHER, POS1)}
		\nope{}
		\ora{isTombable(B)}
	\end{cas}

\obj{Bloc\_invariant5} {minimisation de isSortie}
	\begin{cas}{Bloc\_invariant5}
		\pre{B = init(SORTIE\_OUVERTE, POS1)}
		\nope{}
		\ora{isSortie(B)}
	\end{cas}

\obj{Bloc\_invariant6} {minimisation de isSortieFermee}
	\begin{cas}{Bloc\_invariant6}
		\pre{B = init(SORTIE\_FERMEE, POS1)}
		\nope{}
		\ora{isSortieFermee(B)}
	\end{cas}

\obj{Bloc\_invariant7} {minimisation de isHero}
	\begin{cas}{Bloc\_invariant7}
		\pre{B = init(HERO, POS1)}
		\nope{}
		\ora{isHero(B)}
	\end{cas}

\obj{Bloc\_invariant8} {minimisation de isTerre}
	\begin{cas}{Bloc\_invariant8}
		\pre{B = init(TERRE, POS1)}
		\nope{}
		\ora{isTerre(B)}
	\end{cas}


\subsection{Couverture des postconditions}

\obj{Bloc\_init\_post1} {postcondition de init sur getType}
	\begin{cas}{Bloc\_init\_post1}
		\pre{aucun}
		\ope{B = init(HERO, POS1)}
		\ora{getType(B) = HERO}
	\end{cas}

\obj{Bloc\_init\_post2} {postcondition de init sur getPosition}
	\begin{cas}{Bloc\_init\_post2}
		\pre{aucun}
		\ope{B = init(HERO, POS1)}
		\ora{getPosition(B) = POS1}
	\end{cas}

\obj{Bloc\_setType\_post1} {postcondition de setType sur getType}
	\begin{cas}{Bloc\_setType\_post1}
		\pre{B1 = init(HERO, POS1)}
		\ope{B2 = setType(B1, ROCHER)}
		\ora{getType(B2) = ROCHER}
	\end{cas}


\obj{Bloc\_setType\_post2} {postcondition de setType sur getPosition}
	\begin{cas}{Bloc\_setType\_post2}
		\pre{B1 = init(HERO, POS1)}
		\ope{B2 = setType(B1, ROCHER)}
		\ora{getPosition(B2) = POS1}
	\end{cas}


\subsection{Couverture des transitions}

\obj{Bloc\_setType\_trans} {transition de setType}
	\begin{cas}{Bloc\_setType\_trans}
		\pre{B1 = init(HERO, POS1)}
		\ope{B2 = setType(B1, ROCHER)}
		\ora{getType(B2) = ROCHER \lAND{} getPosition(B2) = POS1}
	\end{cas}

\clearpage{}





















\section{Position}

\subsection{Couverture des préconditions}

\obj{Position\_init\_pre} {précondition de init}

	\begin{cas}{Position\_init\_pre\_true}
		\npre{}
		\nope{}
		\ora{\lEXISTS{} MJ, MJ = init(5, 5, 2, 3)}
	\end{cas}

	\begin{cas}{Position\_init\_pre\_false1}
		\npre{}
		\nope{}
		\ora{\lNEXISTS{} MJ, MJ = init(0, 5, 2, 3)}
	\end{cas}

	\begin{cas}{Position\_init\_pre\_false2}
		\npre{}
		\nope{}
		\ora{\lNEXISTS{} MJ, MJ = init(5, 0, 2, 3)}
	\end{cas}

	\begin{cas}{Position\_init\_pre\_false3}
		\npre{}
		\nope{}
		\ora{\lNEXISTS{} MJ, MJ = init(5, 5, -1, 3)}
	\end{cas}

	\begin{cas}{Position\_init\_pre\_false4}
		\npre{}
		\nope{}
		\ora{\lNEXISTS{} MJ, MJ = init(5, 5, 2, -1)}
	\end{cas}


\subsection{Couverture des invariants}

Aucun invariant dans Position.

\subsection{Couverture des postconditions}

\obj{Position\_init\_post1} {postcondition de init sur getLargeur}
	\begin{cas} {Position\_init\_post1}
		\npre{}
		\ope{P = init(5, 4, 2, 3)}
		\ora{getLargeur(P) = 5}
	\end{cas}

\obj{Position\_init\_post2} {postcondition de init sur getHauteur}
	\begin{cas} {Position\_init\_post2}
		\npre{}
		\ope{P = init(5, 4, 2, 3)}
		\ora{getHauteur(P) = 4}
	\end{cas}


\obj{Position\_init\_post3} {postcondition de init sur getX}
	\begin{cas} {Position\_init\_post3}
		\npre{}
		\ope{P = init(5, 4, 2, 3)}
		\ora{getX(P) = 2 \% 5}
	\end{cas}

\obj{Position\_init\_post4} {postcondition de init sur getY}
	\begin{cas} {Position\_init\_post4}
		\npre{}
		\ope{P = init(5, 4, 2, 3)}
		\ora{getY(P) = 3 \% 4}
	\end{cas}

\obj{Position\_deplacerVersDirection\_post1} {postcondition de deplacerVersDirection sur getX}
	\begin{cas} {Position\_deplacerVersDirection\_post1\_1}
		\pre{P1 = init(5, 4, 2, 3)}
		\ope{P2 = deplacerVersDirection(P1, GAUCHE)}
		\ora{getX(P2) = (2 - 1) \% 5}
	\end{cas}

	\begin{cas} {Position\_deplacerVersDirection\_post1\_2}
		\pre{P1 = init(5, 4, 2, 3)}
		\ope{P2 = deplacerVersDirection(P1, DROITE)}
		\ora{getX(P2) = (2 + 1) \% 5}
	\end{cas}

	\begin{cas} {Position\_deplacerVersDirection\_post1\_3}
		\pre{P1 = init(5, 4, 2, 3)}
		\ope{P2 = deplacerVersDirection(P1, HAUT)}
		\ora{getX(P2) = 2}
	\end{cas}

\obj{Position\_deplacerVersDirection\_post2} {postcondition de deplacerVersDirection sur getY}
	\begin{cas} {Position\_deplacerVersDirection\_post2\_1}
		\pre{P1 = init(5, 4, 2, 3)}
		\ope{P2 = deplacerVersDirection(P1, HAUT)}
		\ora{getY(P2) = (3 - 1) \% 4}
	\end{cas}

	\begin{cas} {Position\_deplacerVersDirection\_post2\_2}
		\pre{P1 = init(5, 4, 2, 3)}
		\ope{P2 = deplacerVersDirection(P1, BAS)}
		\ora{getY(P2) = (3 + 1) \% 4}
	\end{cas}

	\begin{cas} {Position\_deplacerVersDirection\_post2\_3}
		\pre{P1 = init(5, 4, 2, 3)}
		\ope{P2 = deplacerVersDirection(P1, GAUCHE)}
		\ora{getY(P2) = 3}
	\end{cas}


\subsection{Couverture des transitions}

\obj{Position\_deplacerVersDirection\_trans} {transition de deplacerVersDirection}
	\begin{cas} {Position\_deplacerVersDirection\_trans1}
		\pre{P1 = init(5, 4, 2, 3)}
		\ope{P2 = deplacerVersDirection(P1, HAUT)}
		\ora{getY(P2) = (3 - 1) \% 4 \lAND{} getX(P2) = 2}
	\end{cas}

	\begin{cas} {Position\_deplacerVersDirection\_trans2}
		\pre{P1 = init(5, 4, 2, 3)}
		\ope{P2 = deplacerVersDirection(P1, BAS)}
		\ora{getY(P2) = (3 + 1) \% 4 \lAND{} getX(P2) = 2}
	\end{cas}


	\begin{cas} {Position\_deplacerVersDirection\_trans3}
		\pre{P1 = init(5, 4, 2, 3)}
		\ope{P2 = deplacerVersDirection(P1, GAUCHE)}
		\ora{getY(P2) = 3 \lAND{} getX(P2) = (2 - 1) \% 5}
	\end{cas}


	\begin{cas} {Position\_deplacerVersDirection\_trans4}
		\pre{P1 = init(5, 4, 2, 3)}
		\ope{P2 = deplacerVersDirection(P1, DROITE)}
		\ora{getY(P2) = 3 \lAND{} getX(P2) = (2 + 1) \% 5}
	\end{cas}

\clearpage{}





















\section{Terrain}

\subsection{Couverture des préconditions}

\obj{Terrain\_getBlocHero\_pre} {précondition de getBlocHero}
	\begin{cas} {Terrain\_getBlocHero\_pre\_true}
		\pre{TER1}
		\nope{}
		\ora{isHeroVivant(TER1) \lAND{} \lEXISTS{} B, B = getBlocHero(TER1)}
	\end{cas}

	\begin{cas} {Terrain\_getBlocHero\_pre\_false}
		\pre{T = init(5, 5)}
		\nope{}
		\ora{\lNOT{}isHeroVivant(TER1) \lAND{} \lNEXISTS{} B, B = getBlocHero(T)}
	\end{cas}

\obj{Terrain\_init\_pre} {précondition de init}
	\begin{cas} {Terrain\_init\_pre\_true}
		\npre{}
		\nope{}
		\ora{\lEXISTS{} T, T = init(5, 5)}
	\end{cas}

	\begin{cas} {Terrain\_init\_pre\_false1}
		\npre{}
		\nope{}
		\ora{\lNEXISTS{} T, T = init(0, 5)}
	\end{cas}

	\begin{cas} {Terrain\_init\_pre\_false2}
		\npre{}
		\nope{}
		\ora{\lNEXISTS{} T, T = init(5, 0)}
	\end{cas}

\obj{Terrain\_deplacerBlocVersDirection\_pre} {précondition de deplacerBlocVersDirection}
	\begin{cas} {Terrain\_deplacerBlocVersDirection\_pre\_true}
		\pre{TER1}
		\nope{}
		\oram{}
		\begin{lstlisting}
isDeplacementBlocPossible(TER1, getBlocHero(TER1), DROITE)
`\lAND' `\lEXISTS' T2, T2 = deplacerBlocVersDirection(TER1, getBlocHero(TER1), DROITE)
		\end{lstlisting}
	\end{cas}

	\begin{cas} {Terrain\_deplacerBlocVersDirection\_pre\_false}
		\pre{TER1}
		\nope{}
		\oram{}
		\begin{lstlisting}
`\lNOT'isDeplacementBlocPossible(TER1, getBlocHero(TER1), HAUT)
`\lAND' `\lNEXISTS' T2, T2 = deplacerBlocVersDirection(TER1, getBlocHero(TER1), HAUT)
		\end{lstlisting}
	\end{cas}

\subsection{Couverture des invariants}

\obj{Terrain\_invariant1} {minimisation de getBlocHero}
	\begin{cas} {Terrain\_invariant1}
		\pre{TER1}
		\nope{}
		\ora{getBlocHero(TER1) = getBloc(2, 1)}
	\end{cas}

\obj{Terrain\_invariant2} {minimisation de getBlocVersDirection}
	\begin{cas} {Terrain\_invariant2}
		\pre{TER1}
		\nope{}
		\ora{getBlocVersDirection(getBlocHero(TER1), DROITE) = getBloc(3, 1)}
	\end{cas}

\obj{Terrain\_invariant3} {minimisation de isHeroVivant}
	\begin{cas} {Terrain\_invariant3\_true}
		\pre{TER1}
		\nope{}
		\ora{isHeroVivant(TER1)}
	\end{cas}

	\begin{cas} {Terrain\_invariant3\_false}
		\pre{T = init(5, 5)}
		\nope{}
		\ora{\lNOT{}isHeroVivant(T)}
	\end{cas}


\obj{Terrain\_invariant4} {minimisation de isDiamantsRestants}
	\begin{cas} {Terrain\_invariant4\_true}
		\pre{TER1}
		\nope{}
		\ora{isDiamantsRestants(TER1)}
	\end{cas}

	\begin{cas} {Terrain\_invariant4\_false}
		\pre{T = init(5, 5)}
		\nope{}
		\ora{\lNOT{}isDiamantsRestants(T)}
	\end{cas}

\obj{Terrain\_invariant5} {minimisation de isDeplacementBlocPossible}
	\begin{cas} {Terrain\_invariant5\_true}
		\pre{TER1}
		\nope{}
		\ora{isDeplacementBlocPossible(TER1, Terrain::getBlocHero(TER1), DROITE)}
	\end{cas}

	\begin{cas} {Terrain\_invariant5\_false}
		\pre{TER1}
		\nope{}
		\ora{\lNOT{}isDeplacementBlocPossible(TER1, Terrain::getBlocHero(TER1), HAUT)}
	\end{cas}

\obj{Terrain\_invariant6} {minimisation de getBlocDepuisPosition}
	\begin{cas} {Terrain\_invariant6}
		\pre{TER1, POS1}
		\nope{}
		\ora{getBlocDepuisPosition(TER1, POS1) = getBloc(1, 1)}
	\end{cas}

\obj{Terrain\_invariant7} {minimisation de getBlocs}
	\begin{cas} {Terrain\_invariant7}
		\pre{TER1}
		\nope{}
		\oram{}
		\begin{lstlisting}
getBlocs(TER1) = {
	Bloc::init(VIDE, Position::init(0, 0))
	Bloc::init(MUR, Position::init(1, 0))
	Bloc::init(MUR, Position::init(2, 0))
	Bloc::init(MUR, Position::init(3, 0))
	Bloc::init(MUR, Position::init(4, 0))
	Bloc::init(VIDE, Position::init(0, 1))
	Bloc::init(ROCHER, Position::init(1, 1))
	Bloc::init(HERO, Position::init(2, 1))
	Bloc::init(VIDE, Position::init(3, 1))
	Bloc::init(DIAMANT, Position::init(4, 1))
	Bloc::init(VIDE, Position::init(0, 2))
	Bloc::init(VIDE, Position::init(1, 2))
	Bloc::init(VIDE, Position::init(2, 2))
	Bloc::init(VIDE, Position::init(3, 2))
	Bloc::init(SORTIE_FERMEE, Position::init(4, 2))
}
		\end{lstlisting}
	\end{cas}


\subsection{Couverture des postconditions}

\obj{Terrain\_init\_post1} {postcondition de init sur getLargeur}
	\begin{cas} {Terrain\_init\_post1}
		\npre{}
		\ope{T = init(10, 15)}
		\ora{getLargeur(T) = 10}
	\end{cas}


\obj{Terrain\_init\_post2} {postcondition de init sur getHauteur}
	\begin{cas} {Terrain\_init\_post2}
		\npre{}
		\ope{T = init(10, 15)}
		\ora{getHauteur(T) = 15}
	\end{cas}

\obj{Terrain\_init\_post3} {postcondition de init sur getPosSortie}
	\begin{cas} {Terrain\_init\_post3}
		\npre{}
		\ope{T = init(10, 15)}
		\ora{getPosSortie(T) = $\emptyset{}$}
	\end{cas}

\obj{Terrain\_init\_post4} {postcondition de init sur getPosHero}
	\begin{cas} {Terrain\_init\_post4}
		\npre{}
		\ope{T = init(10, 15)}
		\ora{getPosHero(T) = $\emptyset{}$}
	\end{cas}

\obj{Terrain\_init\_post5} {postcondition de init sur getBloc}
	\begin{cas} {Terrain\_init\_post5}
		\npre{}
		\ope{T = init(10, 15)}
		\ora{\lFORALL x $\in$ [0..9], \lFORALL y $\in$ [0..14], getBloc(T, x, y) = $\emptyset{}$}
	\end{cas}

\obj{Terrain\_setBloc\_post1} {postcondition de setBloc sur getPosSortie}
	\begin{cas} {Terrain\_setBloc\_post1\_conseq}
		\pre{TER1}
		\ope{T2 = setBloc(TER1, SORTIE\_FERMEE, 1, 2)}
		\ora{getPosSortie(T2) = Position::init(5, 3, 1, 2)}
	\end{cas}

	\begin{cas} {Terrain\_setBloc\_post1\_alt}
		\pre{TER1}
		\ope{T2 = setBloc(TER1, ROCHER, 1, 2)}
		\ora{getPosSortie(T2) = Position::init(5, 3, 4, 2)}
	\end{cas}

\obj{Terrain\_setBloc\_post2} {postcondition de setBloc sur getPosHero}
	\begin{cas} {Terrain\_setBloc\_post2\_conseq}
		\pre{TER1}
		\ope{T2 = setBloc(TER1, HERO, 1, 2)}
		\ora{getPosHero(T2) = Position::init(5, 3, 1, 2)}
	\end{cas}

	\begin{cas} {Terrain\_setBloc\_post2\_alt}
		\pre{TER1}
		\ope{T2 = setBloc(TER1, VIDE, 1, 2)}
		\ora{getPosHero(T2) = Position::init(5, 3, 2, 1)}
	\end{cas}

\obj{Terrain\_setBloc\_post3} {postcondition de setBloc sur getBloc}
	\begin{cas} {Terrain\_setBloc\_post3}
		\pre{TER1}
		\ope{T2 = setBloc(TER1, ROCHER, 3, 1)}
		\oram{}
		\begin{lstlisting}
`\lFORALL'x `$\in$' [0..4], `\lFORALL'y `$\in$' [0..2],
let bloc = getBloc(T2, x, y)
in
	if x = 3 `\lAND' y = 1 then
		Bloc::getType(bloc) = ROCHER
	else
		bloc = getBloc(TER1, x, y)
		\end{lstlisting}
	\end{cas}

\obj{Terrain\_deplacerBlocVersDirection\_post1} {postcondition de deplacerBlocVersDirection sur getPosSortie}
	\begin{cas} {Terrain\_deplacerBlocVersDirection\_post1}
		\pre{TER1}
		\ope{T2 = deplacerBlocVersDirection(TER1, getBlocHero(TER1), DROITE)}
		\ora{getPosSortie(T2) = Position::init(5, 3, 4, 2)}
	\end{cas}

\obj{Terrain\_deplacerBlocVersDirection\_post2} {postcondition de deplacerBlocVersDirection sur getPosHero}
	\begin{cas} {Terrain\_deplacerBlocVersDirection\_post2\_conseq}
		\pre{TER1}
		\ope{T2 = deplacerBlocVersDirection(TER1, getBlocHero(TER1), DROITE)}
		\ora{getPosHero(T2) = Position::init(5, 3, 3, 1)}
	\end{cas}

	\begin{cas} {Terrain\_deplacerBlocVersDirection\_post2\_alt}
		\pre{TER1}
		\ope{T2 = deplacerBlocVersDirection(TER1, getBloc(1, 1), BAS)}
		\ora{getPosHero(T2) = Position::init(5, 3, 2, 1)}
	\end{cas}

\obj{Terrain\_deplacerBlocVersDirection\_post3} {postcondition de deplacerBlocVersDirection sur getBloc}
	\begin{cas} {Terrain\_deplacerBlocVersDirection\_post3}
		\pre{TER1}
		\ope{T2 = deplacerBlocVersDirection(TER1, getBlocHero(TER1), DROITE)}
		\oram{}
		\begin{lstlisting}
`\lFORALL'x `$\in$' [0..4], `\lFORALL'y `$\in$' [0..2],
let bloc = getBloc(T2, x, y)
in
	if x = 2 `\lAND' y = 1 then
		Bloc::isVide(bloc)
	else if x = 3 `\lAND' y = 1 then
		Bloc::isHero(bloc)
	else
		bloc = getBloc(TER1, x, y)
		\end{lstlisting}
	\end{cas}

\obj{Terrain\_fairePasDeMiseAJour\_post1} {postcondition de fairePasDeMiseAJour sur getPosSortie}
	\begin{cas} {Terrain\_fairePasDeMiseAJour\_post1}
		\pre{TER1}
		\ope{T2 = fairePasDeMiseAJour(TER1)}
		\ora{getPosSortie(T2) = Position::init(5, 3, 4, 2)}
	\end{cas}

\obj{Terrain\_fairePasDeMiseAJour\_post2} {postcondition de fairePasDeMiseAJour sur getPosHero}
	\begin{cas} {Terrain\_fairePasDeMiseAJour\_post2}
		\pre{TER1}
		\ope{T2 = fairePasDeMiseAJour(TER1)}
		\ora{getPosHero(T2) = Position::init(5, 3, 2, 1)}
	\end{cas}

\obj{Terrain\_fairePasDeMiseAJour\_post3} {postcondition de fairePasDeMiseAJour sur getBloc}
	\begin{cas} {Terrain\_fairePasDeMiseAJour\_post3}
		\pre{TER1}
		\ope{T2 = fairePasDeMiseAJour(TER1)}
		\oram{}
		\begin{lstlisting}
`\lFORALL'x `$\in$' [0..4], `\lFORALL'y `$\in$' [0..2],
let bloc = getBloc(T2, x, y)
in
	if x = 1 `\lAND' y = 1 then
		Bloc::isVide(bloc)
	else if x = 1 `\lAND' y = 2 then
		Bloc::getType(bloc) = ROCHER
	else
		bloc = getBloc(TER1, x, y)
		\end{lstlisting}
	\end{cas}


\subsection{Couverture des transitions}

\obj{Terrain\_setBloc\_trans} {transition de setBloc}
	\begin{cas} {Terrain\_setBloc\_trans1}
		\pre{TER1}
		\ope{T2 = setBloc(TER1, SORTIE\_FERMEE, 1, 2)}
		\oram{}
		\begin{lstlisting}
getPosSortie(T2) = Position::init(5, 3, 1, 2)
`\lAND' getPosHero(T2) = Position::init(5, 3, 2, 1)
`\lAND' `\lFORALL'x `$\in$' [0..4], `\lFORALL'y `$\in$' [0..2],
	let bloc = getBloc(T2, x, y)
	in
		if x = 1 `\lAND' y = 2 then
			Bloc::isSortieFermee(bloc)
		else
			bloc = getBloc(TER1, x, y)
		\end{lstlisting}
	\end{cas}

	\begin{cas} {Terrain\_setBloc\_trans2}
		\pre{TER1}
		\ope{T2 = setBloc(TER1, HERO, 1, 2)}
		\oram{}
		\begin{lstlisting}
getPosSortie(T2) = Position::init(5, 3, 4, 2)
`\lAND' getPosHero(T2) = Position::init(5, 3, 1, 2)
`\lAND' `\lFORALL'x `$\in$' [0..4], `\lFORALL'y `$\in$' [0..2],
	let bloc = getBloc(T2, x, y)
	in
		if x = 1 `\lAND' y = 2 then
			Bloc::isHero(bloc)
		else
			bloc = getBloc(TER1, x, y)
		\end{lstlisting}
	\end{cas}

\obj{Terrain\_deplacerBlocVersDirection\_trans} {transition de deplacerBlocVersDirection}
	\begin{cas} {Terrain\_deplacerBlocVersDirection\_trans1}
		\pre{TER1}
		\ope{T2 = deplacerBlocVersDirection(TER1, getBlocHero(TER1), DROITE)}
		\oram{}
		\begin{lstlisting}
getPosSortie(T2) = Position::init(5, 3, 4, 2)
`\lAND' getPosHero(T2) = Position::init(5, 3, 3, 1)
`\lAND' `\lFORALL'x `$\in$' [0..4], `\lFORALL'y `$\in$' [0..2],
	let bloc = getBloc(T2, x, y)
	in
		if x = 2 `\lAND' y = 1 then
			Bloc::isVide(bloc)
		else if x = 3 `\lAND' y = 1 then
			Bloc::isHero(bloc)
		else
			bloc = getBloc(TER1, x, y)
		\end{lstlisting}
	\end{cas}

	\begin{cas} {Terrain\_deplacerBlocVersDirection\_trans2}
		\pre{TER1}
		\ope{T2 = deplacerBlocVersDirection(TER1, getBloc(1, 1), BAS)}
		\oram{}
		\begin{lstlisting}
getPosSortie(T2) = Position::init(5, 3, 4, 2)
`\lAND' getPosHero(T2) = Position::init(5, 3, 2, 1)
`\lAND' `\lFORALL'x `$\in$' [0..4], `\lFORALL'y `$\in$' [0..2],
	let bloc = getBloc(T2, x, y)
	in
		if x = 1 `\lAND' y = 1 then
			Bloc::isVide(bloc)
		else if x = 1 `\lAND' y = 2 then
			Bloc::getType(bloc) = ROCHER
		else
			bloc = getBloc(TER1, x, y)
		\end{lstlisting}
	\end{cas}

\obj{Terrain\_fairePasDeMiseAJour\_trans} {transition de fairePasDeMiseAJour}
	\begin{cas} {Terrain\_fairePasDeMiseAJour\_trans}
		\pre{TER1}
		\ope{T2 = fairePasDeMiseAJour(TER1)}
		\oram{}
		\begin{lstlisting}
getPosSortie(T2) = Position::init(5, 3, 4, 2)
`\lAND' getPosHero(T2) = Position::init(5, 3, 2, 1)
`\lAND' `\lFORALL'x `$\in$' [0..4], `\lFORALL'y `$\in$' [0..2],
	let bloc = getBloc(T2, x, y)
	in
		if x = 1 `\lAND' y = 1 then
			Bloc::isVide(bloc)
		else if x = 1 `\lAND' y = 2 then
			Bloc::getType(bloc) = ROCHER
		else
			bloc = getBloc(TER1, x, y)
		\end{lstlisting}
	\end{cas}


\subsection{Couverture des paires de transitions}

\obj{Terrain\_setBloc\_deplacerBlocVersDirection\_trans} {transitions de setBloc puis deplacerBlocVersDirection}
	\begin{cas} {Terrain\_setBloc\_deplacerBlocVersDirection\_trans}
		\pre{TER1}
		\opem{}
		\begin{lstlisting}
T2 = deplacerBlocVersDirection(setBloc(TER1, TERRE, 0, 0),
		getBlocHero(TER1), DROITE)
		\end{lstlisting}
		\oram{}
		\begin{lstlisting}
getPosSortie(T2) = Position::init(5, 3, 4, 2)
`\lAND' getPosHero(T2) = Position::init(5, 3, 3, 1)
`\lAND' `\lFORALL'x `$\in$' [0..4], `\lFORALL'y `$\in$' [0..2],
	let bloc = getBloc(T2, x, y)
	in
		if x = 0 `\lAND' y = 0 then
			Bloc::isTerre(bloc)
		else if x = 2 `\lAND' y = 1 then
			Bloc::isVide(bloc)
		else if x = 3 `\lAND' y = 1 then
			Bloc::isHero(bloc)
		else
			bloc = getBloc(TER1, x, y)
		\end{lstlisting}
	\end{cas}

\obj{Terrain\_setBloc\_fairePasDeMiseAJour\_trans} {transitions de setBloc puis fairePasDeMiseAJour}
	\begin{cas} {Terrain\_setBloc\_fairePasDeMiseAJour\_trans}
		\pre{TER1}
		\ope{T2 = fairePasDeMiseAJour(setBloc(TER1, TERRE, 0, 0))}
		\oram{}
		\begin{lstlisting}
getPosSortie(T2) = Position::init(5, 3, 4, 2)
`\lAND' getPosHero(T2) = Position::init(5, 3, 2, 1)
`\lAND' `\lFORALL'x `$\in$' [0..4], `\lFORALL'y `$\in$' [0..2],
	let bloc = getBloc(T2, x, y)
	in
		if x = 0 `\lAND' y = 0 then
			Bloc::isTerre(bloc)
		else if x = 1 `\lAND' y = 1 then
			Bloc::isVide(bloc)
		else if x = 1 `\lAND' y = 2 then
			Bloc::getType(bloc) = ROCHER
		else
			bloc = getBloc(TER1, x, y)
		\end{lstlisting}
	\end{cas}

\obj{Terrain\_deplacerBlocVersDirection\_setBloc\_trans} {transitions de deplacerBlocVersDirection puis setBloc}
	\begin{cas} {Terrain\_deplacerBlocVersDirection\_setBloc\_trans}
		\pre{TER1}
		\opem{}
		\begin{lstlisting}
T2 = setBloc(deplacerBlocVersDirection(TER1, getBlocHero(TER1), DROITE),
		TERRE, 0, 0)
		\end{lstlisting}
		\oram{}
		\begin{lstlisting}
getPosSortie(T2) = Position::init(5, 3, 4, 2)
`\lAND' getPosHero(T2) = Position::init(5, 3, 3, 1)
`\lAND' `\lFORALL'x `$\in$' [0..4], `\lFORALL'y `$\in$' [0..2],
	let bloc = getBloc(T2, x, y)
	in
		if x = 0 `\lAND' y = 0 then
			Bloc::isTerre(bloc)
		else if x = 2 `\lAND' y = 1 then
			Bloc::isVide(bloc)
		else if x = 3 `\lAND' y = 1 then
			Bloc::isHero(bloc)
		else
			bloc = getBloc(TER1, x, y)
		\end{lstlisting}
	\end{cas}

\obj{Terrain\_deplacerBlocVersDirection\_fairePasDeMiseAJour\_trans\\} {transitions de deplacerBlocVersDirection puis fairePasDeMiseAJour}
	\begin{cas} {Terrain\_deplacerBlocVersDirection\_fairePasDeMiseAJour\_trans}
		\pre{TER1}
		\opem{}
		\begin{lstlisting}
T2 = fairePasDeMiseAJour(
		deplacerBlocVersDirection(TER1, getBlocHero(TER1), DROITE))
		\end{lstlisting}
		\oram{}
		\begin{lstlisting}
getPosSortie(T2) = Position::init(5, 3, 4, 2)
`\lAND' getPosHero(T2) = Position::init(5, 3, 3, 1)
`\lAND' `\lFORALL'x `$\in$' [0..4], `\lFORALL'y `$\in$' [0..2],
	let bloc = getBloc(T2, x, y)
	in
		if x = 2 `\lAND' y = 1 then
			Bloc::isVide(bloc)
		else if x = 3 `\lAND' y = 1 then
			Bloc::isHero(bloc)
		else if x = 1 `\lAND' y = 1 then
			Bloc::isVide(bloc)
		else if x = 1 `\lAND' y = 2 then
			Bloc::getType(bloc) = ROCHER
		else
			bloc = getBloc(TER1, x, y)
		\end{lstlisting}
	\end{cas}

\obj{Terrain\_fairePasDeMiseAJour\_deplacerBlocVersDirection\_trans\\} {transitions de fairePasDeMiseAJour puis deplacerBlocVersDirection}
	\begin{cas} {Terrain\_fairePasDeMiseAJour\_deplacerBlocVersDirection\_trans}
		\pre{TER1}
		\opem{}
		\begin{lstlisting}
T2 = deplacerBlocVersDirection(fairePasDeMiseAJour(TER1),
		getBlocHero(TER1), DROITE)
		\end{lstlisting}
		\oram{}
		\begin{lstlisting}
getPosSortie(T2) = Position::init(5, 3, 4, 2)
`\lAND' getPosHero(T2) = Position::init(5, 3, 3, 1)
`\lAND' `\lFORALL'x `$\in$' [0..4], `\lFORALL'y `$\in$' [0..2],
	let bloc = getBloc(T2, x, y)
	in
		if x = 2 `\lAND' y = 1 then
			Bloc::isVide(bloc)
		else if x = 3 `\lAND' y = 1 then
			Bloc::isHero(bloc)
		else if x = 1 `\lAND' y = 1 then
			Bloc::isVide(bloc)
		else if x = 1 `\lAND' y = 2 then
			Bloc::getType(bloc) = ROCHER
		else
			bloc = getBloc(TER1, x, y)
		\end{lstlisting}
	\end{cas}

\obj{Terrain\_fairePasDeMiseAJour\_setBloc\_trans} {transitions de fairePasDeMiseAJour puis setBloc}
	\begin{cas} {Terrain\_fairePasDeMiseAJour\_setBloc\_trans}
		\pre{TER1}
		\ope{T2 = setBloc(fairePasDeMiseAJour(TER1), TERRE, 0, 0)}
		\oram{}
		\begin{lstlisting}
getPosSortie(T2) = Position::init(5, 3, 4, 2)
`\lAND' getPosHero(T2) = Position::init(5, 3, 2, 1)
`\lAND' `\lFORALL'x `$\in$' [0..4], `\lFORALL'y `$\in$' [0..2],
	let bloc = getBloc(T2, x, y)
	in
		if x = 0 `\lAND' y = 0 then
			Bloc::isTerre(bloc)
		else if x = 1 `\lAND' y = 1 then
			Bloc::isVide(bloc)
		else if x = 1 `\lAND' y = 2 then
			Bloc::getType(bloc) = ROCHER
		else
			bloc = getBloc(TER1, x, y)
		\end{lstlisting}
	\end{cas}


























\section{MoteurJeu}


\subsection{Couverture des préconditions}

\obj{MoteurJeu\_init\_pre} {précondition de init}
	\begin{cas} {MoteurJeu\_init\_pre\_true}
		\npre{}
		\nope{}
		\ora{\lEXISTS{} MJ, MJ = init(TER1, 30)}
	\end{cas}

	\begin{cas} {MoteurJeu\_init\_pre\_false}
		\npre{}
		\nope{}
		\ora{\lNEXISTS{} MJ, MJ = init(TER1, 0)}
	\end{cas}


\obj{MoteurJeu\_deplacerHero\_pre} {précondition de deplacerHero}
	\begin{cas} {MoteurJeu\_deplacerHero\_pre\_true}
		\pre{MJ1 = init(TER1, 30)}
		\nope{}
		\oram{}
		\begin{lstlisting}
(`\lNOT'isPartieTerminee(MJ1) `\lAND' isDeplacementHeroPossible(MJ1, DROITE))
`\lAND' `\lEXISTS' MJ2, MJ2 = deplacerHero(MJ1, DROITE)
		\end{lstlisting}
	\end{cas}

	\begin{cas} {MoteurJeu\_deplacerHero\_pre\_false1}
		\pre{MJ1 = init(TER1, 30)}
		\nope{}
		\oram{}
		\begin{lstlisting}
`\lNOT'(`\lNOT'isPartieTerminee(MJ1) `\lAND' isDeplacementHeroPossible(MJ1, HAUT))
`\lAND' `\lNEXISTS' MJ2, MJ2 = deplacerHero(MJ1, HAUT)
		\end{lstlisting}
	\end{cas}

	\begin{cas} {MoteurJeu\_deplacerHero\_pre\_false2}
		\pre{MJ1 = deplacerHero(init(TER1, 1), DROITE)}
		\nope{}
		\oram{}
		\begin{lstlisting}
`\lNOT'(`\lNOT'isPartieTerminee(MJ1) `\lAND' isDeplacementHeroPossible(MJ1, HAUT))
`\lAND' `\lNEXISTS' MJ2, MJ2 = deplacerHero(MJ1, GAUCHE)
		\end{lstlisting}
	\end{cas}


\subsection{Couverture des invariants}

\obj{MoteurJeu\_invariant1} {minimisation de isPartieTerminee}
	\begin{cas} {MoteurJeu\_invariant1\_true}
		\pre{MJ = deplacerHero(init(TER1, 1), DROITE)}
		\nope{}
		\ora{isPartieTerminee(MJ)}
	\end{cas}

	\begin{cas} {MoteurJeu\_invariant1\_false}
		\pre{MJ = init(TER1, 30)}
		\nope{}
		\ora{\lNOT{}isPartieTerminee(MJ)}
	\end{cas}

\obj{MoteurJeu\_invariant2} {minimisation de isPartieGagnee}
	\begin{cas} {MoteurJeu\_invariant2\_true}
		\prem{}
		\begin{lstlisting}
MJ =
	fairePasDeMiseAJour(deplacerHero(
		fairePasDeMiseAJour(deplacerHero(
			fairePasDeMiseAJour(deplacerHero(init(TER1, 30), DROITE)),
		DROITE)),
	BAS))
		\end{lstlisting}
		\nope{}
		\ora{isPartieGagnee(MJ)}
	\end{cas}

	\begin{cas} {MoteurJeu\_invariant2\_false}
		\pre{MJ = init(TER1, 30)}
		\nope{}
		\ora{\lNOT{}isPartieGagnee(MJ)}
	\end{cas}

\obj{MoteurJeu\_invariant3} {minimisation de isDeplacementHeroPossible}
	\begin{cas} {MoteurJeu\_invariant3\_conseq}
		\pre{MJ = init(TER1, 30)}
		\nope{}
		\ora{isDeplacementHeroPossible(MJ, DROITE)}
	\end{cas}

	\begin{cas} {MoteurJeu\_invariant3\_alt}
		\pre{MJ = init(TER1, 30)}
		\nope{}
		\ora{isDeplacementHeroPossible(MJ, BAS)}
	\end{cas}


\subsection{Couverture des postconditions}

\obj{MoteurJeu\_init\_post1} {postcondition de init sur getPasRestants}
	\begin{cas} {MoteurJeu\_init\_post1}
		\npre{}
		\ope{MJ = init(TER1, 30)}
		\ora{getPasRestants(MJ) = 30}
	\end{cas}

\obj{MoteurJeu\_init\_post2} {postcondition de init sur getTerrain}
	\begin{cas} {MoteurJeu\_init\_post2}
		\npre{}
		\ope{MJ = init(TER1, 30)}
		\ora{getTerrain(MJ) = TER1}
	\end{cas}

\obj{MoteurJeu\_deplacerHero\_post1} {postcondition de deplacerHero sur getPasRestants}
	\begin{cas} {MoteurJeu\_deplacerHero\_post1}
		\pre{MJ1 = init(TER1, 30)}
		\ope{MJ2 = deplacerHero(MJ, DROITE)}
		\ora{getPasRestants(MJ2) = 30 - 1}
	\end{cas}

\obj{MoteurJeu\_deplacerHero\_post2} {postcondition de deplacerHero sur getTerrain}
	\begin{cas} {MoteurJeu\_deplacerHero\_post2\_1}
		\pre{MJ1 = init(TER1, 30)}
		\ope{MJ2 = deplacerHero(MJ, DROITE)}
		\oram{}
		\begin{lstlisting}
getTerrain(MJ2) =
	Terrain::deplacerBlocVersDirection(TER1, Terrain::getBlocHero(TER1), DROITE)
		\end{lstlisting}
	\end{cas}

	\begin{cas} {MoteurJeu\_deplacerHero\_post2\_2}
		\pre{MJ = init(TER1, 30)}
		\ope{MJ2 = deplacerHero(MJ, GAUCHE)}
		\oram{}
		\begin{lstlisting}
let* blocHero = Terrain::getBlocHero(TER1)
and blocDest = Terrain::getBlocVersDirection(TER1, blocHero, GAUCHE)
in
	getTerrain(MJ2) = Terrain::deplacerBlocVersDirection(
		Terrain::deplacerBlocVersDirection(TER1, blocDest, GAUCHE),
			blocHero, GAUCHE)
		\end{lstlisting}
	\end{cas}


\subsection{Couverture des transitions}

\obj{MoteurJeu\_deplacerHero\_trans} {transition de deplacerHero}
	\begin{cas} {MoteurJeu\_deplacerHero\_trans1}
		\pre{MJ1 = init(TER1, 30)}
		\ope{MJ2 = deplacerHero(MJ, DROITE)}
		\oram{}
		\begin{lstlisting}
getPasRestants(MJ2) = 30 - 1
`\lAND' getTerrain(MJ2) = Terrain::deplacerBlocVersDirection(TER1,
	Terrain::getBlocHero(TER1), DROITE)
		\end{lstlisting}
	\end{cas}

	\begin{cas} {MoteurJeu\_deplacerHero\_trans2}
		\pre{MJ = init(TER1, 30)}
		\ope{MJ2 = deplacerHero(MJ, GAUCHE)}
		\oram{}
		\begin{lstlisting}
let* blocHero = Terrain::getBlocHero(TER1)
and blocDest = Terrain::getBlocVersDirection(TER1, blocHero, GAUCHE)
in
	getPasRestants(MJ2) = 30 - 1
	`\lAND' getTerrain(MJ2) = Terrain::deplacerBlocVersDirection(
		Terrain::deplacerBlocVersDirection(TER1, blocDest, GAUCHE),
			blocHero, GAUCHE)
		\end{lstlisting}
	\end{cas}

\end{document}

