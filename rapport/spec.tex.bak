\documentclass[14pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{lmodern}
\usepackage[cm]{fullpage}

\usepackage{pbox}
\usepackage{titlesec}
% \titlespacing*{\chapter}{0pt}{0pt}{0pt}
\usepackage{graphicx}
\usepackage[parfill]{parskip}
\usepackage[colorlinks=true, urlcolor=black, linkcolor=black, citecolor=black]{hyperref}
\usepackage{amsmath}
\usepackage{tabto}

% Listings --------------------------------------------------------------------%
\usepackage{color}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{caption}
\usepackage{wrapfig}

\DeclareCaptionFont{white}{\color{white}}
\DeclareCaptionFormat{listing}{\colorbox[cmyk]{0.43, 0.35, 0.35,0.01}{\parbox{\textwidth}{\hspace{15pt}#1#2#3}}}
\captionsetup[lstlisting]{format=listing,labelfont=white,textfont=white, singlelinecheck=false, margin=0pt, font={bf,footnotesize}}
\lstset{
	breaklines=true,
	tabsize=2,
	basicstyle=\normalsize\ttfamily,
	columns=fullflexible,
	showstringspaces=false,
	numberstyle=\tiny,
	numbersep=5pt,
	extendedchars=true,
	showspaces=false,
	xleftmargin=17pt,
	framexleftmargin=17pt,
	framexrightmargin=5pt,
	framexbottommargin=4pt
}
%------------------------------------------------------------------------------%

% Todos -----------------------------------------------------------------------%
\setlength{\marginparwidth}{1.2in}
\let\oldmarginpar\marginpar
\renewcommand\marginpar[1]{\-\oldmarginpar[\raggedleft\footnotesize #1]%
{\raggedright\footnotesize #1}}
\newcommand{\note}[1]{\marginpar{\colorbox{yellow}{\begin{minipage}{\linewidth}\textcolor{black}{#1}\end{minipage}}}}
%------------------------------------------------------------------------------%

\newcommand{\tb}{\textbackslash{}}
\newcommand{\cmd}[1]{\texttt{#1}}
\newcommand{\fleche}{~$\rightarrow{}$~}
\newcommand{\fois}{~$\times{}$~}
\newcommand{\eqmin}{~$\overset{min}{=}$~}
\newcommand{\eqdef}{~$\overset{def}{=}$~}
\newcommand{\supeq}{$\geq$~}

\newenvironment{preconditions} {\begin{list}{}{}
} {
	\end{list}
}

\newenvironment{observators} {\servicesec{Observators}\begin{list}{\textbf{-}}{}
} {
	\end{list}
}
\newenvironment{constructors} {\servicesec{Constructors}\begin{list}{\textbf{-}}{}
} {
	\end{list}
}
\newenvironment{operators} {\servicesec{Operators}\begin{list}{\textbf{-}}{}
} {
	\end{list}
}
\newenvironment{observations} {\servicesec{Observations}\begin{list}{}{}
} {
	\end{list}
}
\newenvironment{obsection}[1] {
	\item {\textbf{[#1]}}\begin{list}{\textbf{-}}{}
} {
	\end{list}\vspace{1em}
}
\newenvironment{invariant} {
	\item {\textbf{[invariant]}}\begin{list}{\textbf{-}}{}
} {
	\end{list}\vspace{1em}
}
\newenvironment{lindent} {\begin{list}{}{}} {
	\end{list}
}
\newenvironment{lletall}[1] {
	\begin{lindent}
		\item \textbf{let*} #1
} {
	\end{lindent}
}

\newcommand{\servicesec}[1]{{\large\textbf{#1:}}}
\newcommand{\service}[1]{\servicesec{Service} \cmd{#1}}
\newcommand{\types}[1]{\servicesec{Types} \cmd{#1}}
\newcommand{\use}[1]{\servicesec{Use} \cmd{#1}}
\newcommand{\signature}[3]{\texttt{#1: #2\fleche#3}}
\newcommand{\observator}[3]{\item \signature{#1}{#2}{#3}}
\newcommand{\observatorConst}[3]{\item \textbf{\texttt{const}}~\signature{#1}{#2}{#3}}
\newcommand{\constructor}[3]{\item \signature{#1}{#2}{#3}}
\newcommand{\operator}[3]{\item \signature{#1}{#2}{#3}}
\newcommand{\pre}[2]{\item \cmd{\textbf{pre} #1 \textbf{require} #2}}
\newcommand{\onepre}[2]{
\begin{preconditions}
	\pre{#1}{#2}
\end{preconditions}
}
\newcommand{\observation}[2]{\item \texttt{#1~$=$~#2}}
\newcommand{\minimisation}[2]{\item \texttt{#1\eqmin#2}}
\newcommand{\definition}[2]{\item \texttt{#1\eqdef#2}}

\newcommand{\lIN}[1]{{\tb}in \{#1\}}
\newcommand{\lAND}{$\land$~}
\newcommand{\lOR}{$\lor$~}
\newcommand{\lNOT}{$\lnot$}
\newcommand{\lFORALL}{$\forall$}
\newcommand{\lEXISTS}{$\exists$}
\newcommand{\lif}[3]{
\begin{lindent}
	\item if (#1) then
		\begin{lindent}
			\item #2
		\end{lindent}
	\item else
		\begin{lindent}
			\item #3
		\end{lindent}
\end{lindent}
}
\newcommand{\lelif}[3]{
if (#1) then
	\begin{lindent}
		\item #2
	\end{lindent}
\item else
	\begin{lindent}
		\item #3
	\end{lindent}
}
\newcommand{\lLET}[2]{
\textbf{let} #1\\
\textbf{in} #2
}
\newcommand{\lLETAND}[1]{\item \textbf{and} #1}
\newcommand{\lLETIN}[1]{\item \textbf{in} #1}
\newcommand{\lLETINBLOC}[1]{
\item \textbf{in}
\begin{lindent}
	\item #1
\end{lindent}}


\newcommand{\Bloc}{Bloc}
\newcommand{\Position}{Position}
\newcommand{\MoteurJeu}{MoteurJeu}
\newcommand{\Terrain}{Terrain}
\newcommand{\TypeBloc}{TypeBloc}
\newcommand{\defTypeBloc}{enum \TypeBloc~\{~VIDE, TERRE, MUR, HERO, SORTIE\_FERMEE, SORTIE\_OUVERTE, ROCHER, DIAMANT~\}}
\newcommand{\Direction}{Direction}
\newcommand{\defDirection}{enum \Direction~\{~HAUT, BAS, GAUCHE, DROITE~\}}
\newcommand{\Boolean}{\emph{boolean}}
\newcommand{\Integer}{\emph{integer}}
\newcommand{\tBloc}{[\Bloc]}
\newcommand{\tPosition}{[\Position]}
\newcommand{\tMoteurJeu}{[\MoteurJeu]}
\newcommand{\tTerrain}{[\Terrain]}

\title{SpÃ©cification du Boulder Dash}

\author{}

\date{}

\begin{document}

\maketitle{}

\section{Service Bloc}

\service{\Bloc}

\types{\Boolean, \defTypeBloc}

\use{\Position}

\begin{observators}
	\observator{getType} {\tBloc} {\TypeBloc}
	\observator{getPosition} {\tBloc} {\Position}
	\observator{isVide} {\tBloc}  {\Boolean}
	\observator{isSolide} {\tBloc} {\Boolean}
	\observator{isDeplacable} {\tBloc} {\Boolean}
	\observator{isTombable} {\tBloc} {\Boolean}
	\observator{isSortie} {\tBloc} {\Boolean}
		\onepre{isSortie(b)} {Test}
	\observator{isSortieFermee} {\tBloc} {\Boolean}
\end{observators}

\begin{constructors}
	\constructor{init} {\TypeBloc \fois \Position} {\tBloc}
\end{constructors}

\begin{operators}
	\operator{setType}{\tBloc \fois \TypeBloc}{\tBloc}
\end{operators}

\begin{observations}
	\begin{invariant}
		\minimisation{isVide(b)} {getType(b) = VIDE}
		\minimisation{isSolide(b)} {getType(b) \lIN { SORTIE\_FERMEE, MUR, ROCHER }}
		\minimisation{isDeplacable(b)} {getType(b) = ROCHER}
		\minimisation{isTombable(b)} {getType(b) \lIN { ROCHER, DIAMANT }}
		\minimisation{isSortie(b)} {getType(b) \lIN { SORTIE\_FERMEE, SORTIE\_OUVERTE }}
		\minimisation{isSortieFermee(b)} {getType(b) = SORTIE\_FERMEE}
	\end{invariant}
	
	\begin{obsection}{init}
		\observation{getType(init(tb, pos))} {tb}
		\observation{getPosition(init(tb, pos))} {pos}
	\end{obsection}
	
	\begin{obsection}{setType}
		\observation{getType(setType(b, tb))} {tb}
		\observation{getPosition(setType(b, tb))} {getPosition(b)}
	\end{obsection}
\end{observations}





\section{Service Position}

\service{\Position}

\types{\Integer, \defDirection}

\begin{observators}
	\observatorConst{getLargeur} {\tPosition} {\Integer}
	\observatorConst{getHauteur} {\tPosition} {\Integer}
	\observator{getX} {\tPosition} {\Integer}
	\observator{getY} {\tPosition} {\Integer}
\end{observators}

\begin{constructors}
	\constructor{init} {\Integer \fois \Integer \fois \Integer \fois \Integer} {\tPosition}
		\onepre{init(l, h, x, y)} {(l > 0) \lAND (h > 0) \lAND (x \supeq 0) \lAND (y \supeq 0)}
\end{constructors}

\begin{operators}
	\operator{deplacerVersDirection} {\tPosition \fois \Direction} {\tPosition}
\end{operators}

\begin{observations}
	\begin{obsection}{init}
		\observation{getLargeur(init(l, h, x, y))} {l}
		\observation{getHauteur(init(l, h, x, y))} {h}
		\observation{getX(init(l, h, x, y))} {x mod l}
		\observation{getY(init(l, h, x, y))} {y mod h}

	\end{obsection}
	
	\begin{obsection}{deplacerVersDirection}
		\observation{getX(deplacerVersDirection(p, dir))} {
			\lif {dir = GAUCHE} {(getX(p) - 1) mod getLargeur(p)} {
				\lelif {dir = DROITE} {(getX(p) + 1) mod getLargeur(p)} {
					getX(p)
				}
			}
		}
		\observation{getY(deplacerVersDirection(p, dir))} {
			\lif {dir = HAUT} {(getY(p) - 1) mod getHauteur(p)} {
				\lelif {dir = BAS} {(getY(p) + 1) mod getHauteur(p)} {
					getY(p)
				}
			}
		}

	\end{obsection}
\end{observations}




\section{Service MoteurJeu}

\service{MoteurJeu}

\types{\Integer, \Boolean, \defDirection, \defTypeBloc}

\use{\Terrain, \Bloc, \Position}

\begin{observators}
	\observator{getTerrain} {\tMoteurJeu} {\Terrain}
	\observator{getPasRestants} {\tMoteurJeu} {\Integer}
	\observator{isDeplacementHeroPossible} {\tMoteurJeu \fois \Direction} {\Boolean}
	\observator{isPartieTerminee} {\tMoteurJeu} {\Boolean}
	\observator{isPartieGagnee} {\tMoteurJeu} {\Boolean}
\end{observators}

\begin{constructors}
	\constructor{init} {\Terrain \fois \Integer} {\tMoteurJeu}
		\onepre{init(t, nbPas)} {nbPas > 0}
\end{constructors}

\begin{operators}
	\operator{deplacerHero} {\tMoteurJeu \fois \Direction} {\tMoteurJeu}
		\onepre{deplacerHero(mj, dir)} {\lNOT{}isPartieTerminee(mj) \lAND isDeplacementHeroPossible(mj, dir)}
\end{operators}

\begin{observations}
	\begin{invariant}
		\minimisation{isPartieTerminee(mj)} {
			getPasRestants(mj) = 0\\
			\lOR \lNOT{}\Terrain::isHeroVivant(getTerrain(mj))\\
			\lOR \Terrain::getPosSortie(getTerrain(mj)) = \Terrain::getPosHero(getTerrain(mj))}
		\minimisation{isPartieGagnee(mj)} {isPartieTerminee(mj) \lAND \Terrain::isHeroVivant(getTerrain(mj))}
		\minimisation{\lFORALL{}dir \lIN { GAUCHE, DROITE }, isDeplacementHeroPossible(mj, dir)} {
			\begin{lletall}{terrain = getTerrain(mj)}
				\lLETAND{blocHero = \Terrain::getBlocHero(terrain)}
				\lLETAND{blocDest = \Terrain::getBlocVersDirection(terrain, blocHero, dir)}
				\lLETINBLOC{
					\lNOT{}\Bloc::isSolide(blocDest) \lOR
					(\Bloc::isDeplacable(blocDest)\\ \lAND \Bloc::isVide(\Terrain::getBlocVersDirection(terrain, blocDest, dir))
				}
			\end{lletall}
		}
		\minimisation{\lFORALL{}dir \lIN { HAUT, BAS },isDeplacementHeroPossible(mj, dir)} {
			\begin{lletall}{terrain = getTerrain(mj)}
				\lLETAND{blocHero = \Terrain::getBlocHero(terrain)}
				\lLETAND{blocDest = \Terrain::getBlocVersDirection(terrain, blocHero, dir)}
				\lLETIN {\lNOT\Bloc::isSolide(blocDest)}
			\end{lletall}
		}
	\end{invariant}
	
	\begin{obsection}{init}
		\observation{getTerrain(init(t, nbPas))} {t}
		\observation{getPasRestants(init(t, nbPas))} {nbPas}
	\end{obsection}
	
	\begin{obsection}{deplacerHero}
		\observation{getTerrain(deplacerHero(mj, dir))} {
			\begin{lletall}{terrain = getTerrain(mj)}
				\lLETAND{blocHero = \Terrain::getBlocHero(terrain)}
				\lLETAND{blocDest = \Terrain::getBlocVersDirection(terrain, blocHero, dir)}
				\lLETINBLOC{
					\lif {\lNOT\Bloc::isSolide(blocDest)} {\Terrain::deplacerBlocVersDirection(terrain, blocHero, dir)} {
						\lelif {\Bloc::isDeplacable(blocDest) \lAND dir \lIN { GAUCHE, DROITE }} {
							test
						}
					}
				}
			\end{lletall}
		}
		\observation{getPasRestants(deplacerHero(mj, dir))} {getPasRestants(mj) - 1}
		
	\end{obsection}
\end{observations}
		
							% 
							% \lLET{terrain' = \Terrain::deplacerBlocVersDirection(terrain, blocDest, dir)}
							% {\Terrain::deplacerBlocVersDirection(terrain', blocHero, dir)}
	


\subsection{Exemple : spÃ©cification d'une lumiÃ¨re}

\begin{lstlisting}
Service: Light
Types: boolean

Observators:
	isOn: [Light] -> boolean
	
Constructors:
	init: -> [Light]
	
Operators:
	switchOn: [Light] -> [Light]
		pre: switchOn(L) require !isOn(L)
	switchOff: [Light] -> [Light]
		pre: switchOff(L) require isOn(L)
		
Observations:
	[init]
		isOn(init()) = false
	[switchOn]
		isOn(switchOn(L)) = true
	[switchOff]
		isOn(switchOff(L)) = false
\end{lstlisting}

\subsubsection{Raffinement}

\begin{lstlisting}
Service: TrafficLight
Types: enum Color {RED, ORANGE, GREEN}
Refine: Light [1]

Observators: [2, 3]
	getColor: [TrafficLight] -> Color
		pre: getColor(L) require isOn(L)
	
Constructors: [4]
	init: -> [TrafficLight]
	
Operators: [5, 6]
	change: [TrafficLight] -> [TrafficLight]
		pre: change(L) require isOn(L)
		
Observations:
	[init] [7]
		isOn(init()) = false
		[8]
	[switchOn]
		getColor(switchOn(L)) = ORANGE
		[9]
	[change]
		isOn(change(L)) = isOn(L)
		if getColor(L) = RED then getColor(change(L)) = GREEN
		else if getColor(L) = ORANGE then getColor(change(L)) = RED
		else getColor(change(L)) = ORANGE
		
\end{lstlisting}

\begin{enumerate}
	\item il s'agit d'une intention, il faut vÃ©rifier que le raffinement est correct, sinon on utilise Include et pas Refine
	\item on peut ajouter des observateurs
	\item on peut modifier les prÃ©conditions d'un observateur \og{}hÃ©ritÃ©\fg{}
	\item attention, on \og{}n'hÃ©rite pas\fg{} des constructeurs
	\item on peut ajouter des opÃ©rateurs
	\item on peut modifier les prÃ©conditions d'un opÃ©rateur \og{}hÃ©ritÃ©\fg{}
	\item on \og{}n'hÃ©rite pas\fg{} des observations sur init, donc il faut les rajouter
	\item pas le droit d'observer getColor(init()) car la prÃ©-cond n'est pas vÃ©rifiÃ©e Ã  l'initialisation
	\item implicitement par l'hÃ©ritage, on a aussi is On(switchOn(L)) = true
\end{enumerate}

\subsection{Questions Ã  se poser lors d'un raffinement}

\begin{itemize}
	\item cohÃ©rence des modifications et des ajouts
	\item correction du raffinement
\end{itemize}

\subsubsection{Correction du raffinement -- raffinement de fonction (notion de sous-ensemble)}

\underline{\textbf{Exemple:}}

	Soit une fonction \texttt{fun: T -> U, domaine(fun) = T, co-domaine(fun) = U}.
	
	Une fonction \texttt{rfun} raffine \texttt{fun} (\texttt{rfun $\subseteq{}$ fun}) ssi\\
	\texttt{dom(rfun) $\supseteq{}$ dom{fun}} (-> contra-variance des arguments)\\
	\texttt{cod{rfun} $\subseteq{}$ cod{fun}} (-> covariance de la valeur de retour)\\

\underline{\textbf{Justification:}}

	On doit pouvoir utiliser rfun dans tout context oÃ¹ on peut utiliser fun.
	
	\texttt{dom(rfun) $\supseteq$ dom(fun)} -> si fun accepte une valeur de type T alors rfun doit l'accepter aussi -> \og{}au moins T\fg{}
	\texttt{cod(rfun) $\subseteq$ cod(fun)} -> tout contexte qui utilise la valeur de retour de fun s'attend Ã  une valeur de type U, il ne peut accepter lus que U -- \og{}au moins U\fg{}
\\

\underline{\textbf{Exercice:}}

\texttt{fun: R -> R (on suppose N $subseteq{}$ R $subseteq{}$ C)}
\begin{itemize}
	\item \texttt{rfun: R -> N, rfun $\subseteq{}$ fun} : OUI
	\item \texttt{rfun: N -> R, contre-ex: fun(4.3): valide, rfun(4.3): invalide}
	\item \texttt{rfun: C -> N, rfun $\subseteq{}$ fun} : OUI
\end{itemize}

\subsection{InterprÃ©tation logique du raffinement}

soit une opÃ©ration: \texttt{fun: T1 x ... x Tn -> U}

\begin{itemize}
	\item \texttt{dom(fun) = {(v1, ..., vn) | pre(v1, ..., vn) = true}}
	\item \texttt{cod(fun) = {v $\in{}$ U} | obs(v1, ..., vn) = v, post(v, v1, ..., vn) = true}
\end{itemize}

on a :

\begin{itemize}
	\item \texttt{dom(rfun) $\supseteq{}$ dom(fun)} ssi \texttt{pre(v1, ..., vn) $\Rightarrow{}$ rpre(v1, ..., vn)}
	\item \texttt{cod(rfun) $\subseteq{}$ cod(fun)} ssi \texttt{rpost(v1, ..., vn) $\Rightarrow{}$ rpre(v, v1, ..., vn)}
\end{itemize}

\subsection{Raffinement dans les spÃ©cifications}

\begin{lstlisting}
Service: S

Operators:
	op:	[S] -> [S]
		pre: op(s) require P

Observations:
	[Invariants]
		I
	[op]
		Q

Service: S'
Refine: S

Operators:
	op: [S' -> [S']]
		pre: op(s) require P'
Observations:
	[Invariants]
		I'
	[op]
		Q'
\end{lstlisting}

\textbf{\underline{Conditions pour la correction du raffinement (de op) :}}

\begin{itemize}
	\item P $\Rightarrow{}$ P' (sauf constructeurs)
	\item Q' $\Rightarrow{}$ Q (sauf constructeurs et observateurs)
	\item I' $\Rightarrow{}$ I
\end{itemize}

\textbf{\underline{Exemple :}} TrafficLight est un raffinement correct de Light
\\

\textbf{\underline{Contre-exemples :}} Dans TrafficLight,

\begin{itemize}
	\item ajout d'une prÃ©-condition Ã  switchOff: \texttt{pre(switchOff(L) require getColor(L) = ORANGE)} -- incorrect car true n'implique pas getColor(L) = ORANGE
	\item changement d'une observation : \texttt{isOn(change(L)) = false} -- incorrect car isOn(change(L)) = false n'implique pas isOn(change(L)) = true
\end{itemize}

\section{HÃ©ritage dans les contrats}

\subsection{Conditions Ã  respecter pour qu'un contrat C' soit un hÃ©ritage correct de C}

\begin{itemize}
	\item les invariants hÃ©ritÃ©s inv$_{C'} \Rightarrow{}$ inv$_{C}$ invariant de C
	\item pour chaque mÃ©thode \texttt{m} \emph{surdÃ©finie} :
	\begin{itemize}
		\item prÃ©-condition de m dans C pre$_{C,m} \Rightarrow{}$ pre$_{C',m}$ prÃ©-condition hÃ©ritÃ©e
		\item post-condition de m dans C' post$_{C',m} \Rightarrow{}$ post$_{C,m}$ post-condition dans le \og{}super-contrat\fg{}.
	\end{itemize}
\end{itemize}

\subsection{ProblÃ¨me : comment dÃ©duire les tests de pre$_{C,m} \Rightarrow{}$ pre$_{C',m}$ Ã  partir des tests de pre$_{C,m} \Rightarrow{}$ et pre$_{C',m}$}

(et les post)

Solutions possibles (partielles) :

\begin{itemize}
	\item percolateurs, p.ex. dans Eiffel :
	\begin{itemize}
		\item soit \texttt{post'' = post $\land{}$ post'} alors \texttt{post'' $\Rightarrow{}$ post} (implicite)
		\item soit \texttt{pre'' = pre $\lor{}$ pre'} alors \texttt{pre $\Rightarrow{}$ pre''}
		\begin{itemize}
			\item on teste pre', si OK alors OK, sinon, on test pre.
		\end{itemize}
	\end{itemize}
\end{itemize}

\end{document}

